<%
require 'digest'
url_list = []
ignored_file_patterns = [
	'service-worker',
	'sitemap',
	'robots',
	'humans',
	'touch-icon',
	'opengraph',
	'favicon',
	'styleguide',
	'blog',
	'.jpg',
	'.png',
	'.gif'
]
sitemap.resources.each do |r|
	unless ignored_file_patterns.any? {|pattern| r.url.include? pattern}
		url_list.push r.url
	end
end
fingerprint = Digest::MD5.hexdigest(url_list.sort.join(''))
git_revision = `git rev-parse HEAD`.chomp
%>

var APP_PREFIX = 'Abletech_';      // Identifier for this app (this needs to be consistent across every cache update)
var FINGERPRINT = '<%= fingerprint  + git_revision %>'; // Generated hash for the URL list
var CACHE_NAME = APP_PREFIX + FINGERPRINT;
var URLS = [                            // Add URL you want to cache in this list.
<% url_list.each_with_index do |r,i| %>
  <%= "'#{r}'" %><%= ',' unless i == url_list.size - 1 %>
<% end %>
];

// Respond with cached resources
self.addEventListener('fetch', function (e) {
	<%= "console.log('fetch request : ' + e.request.url);" if env_name != 'production' %>
	e.respondWith(
		caches.match(e.request).then(function (request) {
			if (request) { // if cache is available, respond with cache
				<%= "console.log('responding with cache : ' + e.request.url);" if env_name != 'production' %>
				return request;
			} else {       // if there are no cache, try fetching request
				<%= "console.log('file is not cached, fetching : ' + e.request.url);" if env_name != 'production' %>
				return fetch(e.request);
			}

			// You can omit if/else for console.log & put one line below like this too.
			// return request || fetch(e.request)
		})
	);
});

// Cache resources
self.addEventListener('install', function (e) {
	e.waitUntil(
		caches.open(CACHE_NAME).then(function (cache) {
			<%= "console.log('installing cache : ' + CACHE_NAME);" if env_name != 'production' %>
			return cache.addAll(URLS);
		})
	);
});

// Delete outdated caches
self.addEventListener('activate', function (e) {
	<%= "console.log('activate called');" if env_name != 'production' %>
	e.waitUntil(
		caches
			/* This method returns a promise which will resolve to an array of available
				 cache keys.
			*/
			.keys()
			.then(function (keyList) {
				<%= "console.log('keyList', keyList);" if env_name != 'production' %>
				// We return a promise that settles when all outdated caches are deleted.
				return Promise.all(
					keyList
						.filter(function (key) {
							// Filter by keys that don't start with the latest version prefix.
							return !key.startsWith(CACHE_NAME);
						})
						.map(function (key) {
							/* Return a promise that's fulfilled
								 when each outdated cache is deleted.
							*/
							return caches.delete(key);
						})
				);
			})
			<%= ".then(function() {console.log('WORKER: activate completed.');})" if env_name != 'production' %>
	);
});
